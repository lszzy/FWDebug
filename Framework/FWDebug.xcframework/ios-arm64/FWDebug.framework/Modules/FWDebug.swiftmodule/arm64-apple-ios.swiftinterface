// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name FWDebug
@_exported import FWDebug
import Foundation
import MachO
import ObjectiveC
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct AnonymousDescriptor : FWDebug.ContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var anonymousFlags: FWDebug.AnonymousDescriptor.Flags {
    get
  }
  public var mangledName: Swift.String? {
    get
  }
}
extension FWDebug.AnonymousDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.AnonymousDescriptor, b: FWDebug.AnonymousDescriptor) -> Swift.Bool
}
extension Swift.Bool : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Bool
    @usableFromInline
    internal var _storage: FWDebug._AtomicBoolStorage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Bool) {
      _storage = _sa_prepare_Bool(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Bool.AtomicRepresentation.Value {
      _sa_dispose_Bool(_storage)
    }
  }
}
extension Swift.Bool.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<FWDebug._AtomicBoolStorage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _AtomicBoolStorage.self)
  }
}
extension Swift.Bool.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Bool {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_Bool(_extract(pointer))
    case .acquiring:
      return _sa_load_acquire_Bool(_extract(pointer))
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_Bool(_extract(pointer))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_Bool(_extract(pointer), desired)
    case .releasing:
      _sa_store_release_Bool(_extract(pointer), desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_Bool(_extract(pointer), desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Bool {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_Bool(_extract(pointer), desired)
    case .acquiring:
      return _sa_exchange_acquire_Bool(_extract(pointer), desired)
    case .releasing:
      return _sa_exchange_release_Bool(_extract(pointer), desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_Bool(_extract(pointer), desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_Bool(_extract(pointer), desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Bool, desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Bool) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Bool(
        _extract(pointer),
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Bool(
        _extract(pointer),
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_Bool(
        _extract(pointer),
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Bool(
        _extract(pointer),
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Bool, desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Bool) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Bool, desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Bool) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_Bool(
        _extract(pointer),
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Bool(
        _extract(pointer),
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.Bool.AtomicRepresentation {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenLogicalAnd(with operand: Swift.Bool.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Bool.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_Bool(
        _extract(pointer),
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_Bool(
        _extract(pointer),
        operand)
    case .releasing:
      return _sa_fetch_and_release_Bool(
        _extract(pointer),
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_Bool(
        _extract(pointer),
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_Bool(
        _extract(pointer),
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenLogicalOr(with operand: Swift.Bool.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Bool.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_Bool(
        _extract(pointer),
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_Bool(
        _extract(pointer),
        operand)
    case .releasing:
      return _sa_fetch_or_release_Bool(
        _extract(pointer),
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_Bool(
        _extract(pointer),
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_Bool(
        _extract(pointer),
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenLogicalXor(with operand: Swift.Bool.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Bool.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_Bool(
        _extract(pointer),
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_Bool(
        _extract(pointer),
        operand)
    case .releasing:
      return _sa_fetch_xor_release_Bool(
        _extract(pointer),
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_Bool(
        _extract(pointer),
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_Bool(
        _extract(pointer),
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension FWDebug.UnsafeAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalAnd(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalOr(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalXor(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
}
extension FWDebug.UnsafeAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalAndThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original && operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalOrThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original || operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalXorThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original != operand
  }
}
extension FWDebug.ManagedAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalAnd(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalOr(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalXor(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
}
extension FWDebug.ManagedAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalAndThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original && operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalOrThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original || operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalXorThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original != operand
  }
}
public protocol AtomicInteger : FWDebug.AtomicValue, Swift.FixedWidthInteger where Self.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
}
public protocol AtomicIntegerStorage : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenWrappingIncrement(by operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenWrappingDecrement(by operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenBitwiseAnd(with operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenBitwiseOr(with operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenBitwiseXor(with operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicUpdateOrdering) -> Self.Value
}
@frozen public struct UnsafeAtomicLazyReference<Instance> where Instance : AnyObject {
  public typealias Value = Instance?
  @usableFromInline
  internal typealias _Rep = Swift.Optional<Swift.Unmanaged<Instance>>.AtomicRepresentation
  @usableFromInline
  internal let _ptr: Swift.UnsafeMutablePointer<FWDebug.UnsafeAtomicLazyReference<Instance>._Rep>
  @_transparent public init(@_nonEphemeral at pointer: Swift.UnsafeMutablePointer<FWDebug.UnsafeAtomicLazyReference<Instance>.Storage>) {
    // `Storage` is layout-compatible with its only stored property.
    _ptr = UnsafeMutableRawPointer(pointer).assumingMemoryBound(to: _Rep.self)
  }
}
extension FWDebug.UnsafeAtomicLazyReference : @unchecked Swift.Sendable where Instance : Swift.Sendable {
}
extension FWDebug.UnsafeAtomicLazyReference {
  @frozen public struct Storage {
    @usableFromInline
    internal var _storage: FWDebug.UnsafeAtomicLazyReference<Instance>._Rep
    @inlinable @inline(__always) public init() {
      _storage = _Rep(nil)
    }
    @discardableResult
    @inlinable @inline(__always) public mutating func dispose() -> FWDebug.UnsafeAtomicLazyReference<Instance>.Value {
      defer { _storage = _Rep(nil) }
      return _storage.dispose()?.takeRetainedValue()
    }
  }
}
extension FWDebug.UnsafeAtomicLazyReference {
  @inlinable public static func create() -> FWDebug.UnsafeAtomicLazyReference<Instance> {
    let ptr = UnsafeMutablePointer<Storage>.allocate(capacity: 1)
    ptr.initialize(to: Storage())
    return Self(at: ptr)
  }
  @discardableResult
  @inlinable public func destroy() -> FWDebug.UnsafeAtomicLazyReference<Instance>.Value {
    // `Storage` is layout-compatible with its only stored property.
    let address = UnsafeMutableRawPointer(_ptr)
      .assumingMemoryBound(to: Storage.self)
    defer { address.deallocate() }
    return address.pointee.dispose()
  }
}
@_fixed_layout public class ManagedAtomicLazyReference<Instance> where Instance : AnyObject {
  public typealias Value = Instance?
  @usableFromInline
  internal typealias _Rep = Swift.Optional<Swift.Unmanaged<Instance>>.AtomicRepresentation
  @usableFromInline
  final internal let _storage: FWDebug.ManagedAtomicLazyReference<Instance>._Rep
  @inlinable public init() {
    _storage = _Rep(nil)
  }
  @_alwaysEmitIntoClient @inline(__always) internal var _ptr: Swift.UnsafeMutablePointer<FWDebug.ManagedAtomicLazyReference<Instance>._Rep> {
    get {
    _getUnsafePointerToStoredProperties(self).assumingMemoryBound(to: _Rep.self)
  }
  }
  @objc deinit
}
extension FWDebug.UnsafeAtomicLazyReference {
  public func storeIfNilThenLoad(_ desired: __owned Instance) -> Instance
  public func load() -> Instance?
}
extension FWDebug.ManagedAtomicLazyReference {
  public func storeIfNilThenLoad(_ desired: __owned Instance) -> Instance
  public func load() -> Instance?
}
@frozen public struct AtomicLoadOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @_semantics("constant_evaluable") @inlinable @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
extension FWDebug.AtomicLoadOrdering {
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: FWDebug.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiring: FWDebug.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 2)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: FWDebug.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
extension FWDebug.AtomicLoadOrdering : Swift.Equatable {
  @_transparent public static func == (left: FWDebug.AtomicLoadOrdering, right: FWDebug.AtomicLoadOrdering) -> Swift.Bool {
    return left._rawValue == right._rawValue
  }
}
extension FWDebug.AtomicLoadOrdering : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension FWDebug.AtomicLoadOrdering : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@frozen public struct AtomicStoreOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @_semantics("constant_evaluable") @inlinable @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
extension FWDebug.AtomicStoreOrdering {
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: FWDebug.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var releasing: FWDebug.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 3)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: FWDebug.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
extension FWDebug.AtomicStoreOrdering : Swift.Equatable {
  @_transparent public static func == (left: FWDebug.AtomicStoreOrdering, right: FWDebug.AtomicStoreOrdering) -> Swift.Bool {
    return left._rawValue == right._rawValue
  }
}
extension FWDebug.AtomicStoreOrdering : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension FWDebug.AtomicStoreOrdering : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@frozen public struct AtomicUpdateOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @_semantics("constant_evaluable") @inlinable @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
extension FWDebug.AtomicUpdateOrdering {
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: FWDebug.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiring: FWDebug.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 2)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var releasing: FWDebug.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 3)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiringAndReleasing: FWDebug.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 4)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: FWDebug.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
extension FWDebug.AtomicUpdateOrdering : Swift.Equatable {
  @_transparent public static func == (left: FWDebug.AtomicUpdateOrdering, right: FWDebug.AtomicUpdateOrdering) -> Swift.Bool {
    return left._rawValue == right._rawValue
  }
}
extension FWDebug.AtomicUpdateOrdering : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension FWDebug.AtomicUpdateOrdering : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_semantics("atomics.requires_constant_orderings") @_transparent public func atomicMemoryFence(ordering: FWDebug.AtomicUpdateOrdering) {
  switch ordering {
  case .relaxed: break
  case .acquiring: _sa_thread_fence_acquire()
  case .releasing: _sa_thread_fence_release()
  case .acquiringAndReleasing: _sa_thread_fence_acq_rel()
  case .sequentiallyConsistent: _sa_thread_fence_seq_cst()
  default: fatalError()
  }
}
public protocol AtomicOptionalWrappable : FWDebug.AtomicValue {
  associatedtype AtomicOptionalRepresentation : FWDebug.AtomicStorage where Self.AtomicOptionalRepresentation.Value == Self?
}
extension Swift.Optional : FWDebug.AtomicValue where Wrapped : FWDebug.AtomicOptionalWrappable {
  public typealias AtomicRepresentation = Wrapped.AtomicOptionalRepresentation
}
extension Swift.RawRepresentable where Self : FWDebug.AtomicValue, Self.RawValue : FWDebug.AtomicValue {
  public typealias AtomicRepresentation = FWDebug.AtomicRawRepresentableStorage<Self>
}
@frozen public struct AtomicRawRepresentableStorage<Value> : FWDebug.AtomicStorage where Value : Swift.RawRepresentable, Value.RawValue : FWDebug.AtomicValue {
  @usableFromInline
  internal typealias Storage = Value.RawValue.AtomicRepresentation
  @usableFromInline
  internal var _storage: FWDebug.AtomicRawRepresentableStorage<Value>.Storage
  @_transparent @_alwaysEmitIntoClient public init(_ value: __owned Value) {
    _storage = Storage(value.rawValue)
  }
  @_transparent @_alwaysEmitIntoClient public func dispose() -> Value {
    Value(rawValue: _storage.dispose())!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>>) -> Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>.Storage> {
    // `Self` is layout-compatible with its only stored property.
    UnsafeMutableRawPointer(ptr).assumingMemoryBound(to: Storage.self)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>>, ordering: FWDebug.AtomicLoadOrdering) -> Value {
    let raw = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return Value(rawValue: raw)!
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(desired.rawValue, at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>>, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let raw = Storage.atomicExchange(desired.rawValue, at: _extract(pointer), ordering: ordering)
    return Value(rawValue: raw)!
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Value, desired: Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let raw = Storage.atomicCompareExchange(
            expected: expected.rawValue,
            desired: desired.rawValue,
            at: _extract(pointer),
            ordering: ordering)
    return (raw.exchanged, Value(rawValue: raw.original)!)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Value, desired: Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let raw = Storage.atomicCompareExchange(
            expected: expected.rawValue,
            desired: desired.rawValue,
            at: _extract(pointer),
            successOrdering: successOrdering,
            failureOrdering: failureOrdering)
    return (raw.exchanged, Value(rawValue: raw.original)!)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Value, desired: Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicRawRepresentableStorage<Value>>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let raw = Storage.atomicWeakCompareExchange(
            expected: expected.rawValue,
            desired: desired.rawValue,
            at: _extract(pointer),
            successOrdering: successOrdering,
            failureOrdering: failureOrdering)
    return (raw.exchanged, Value(rawValue: raw.original)!)
  }
}
public protocol AtomicReference : AnyObject, FWDebug.AtomicOptionalWrappable where Self.AtomicOptionalRepresentation == FWDebug.AtomicOptionalReferenceStorage<Self>, Self.AtomicRepresentation == FWDebug.AtomicReferenceStorage<Self> {
  override associatedtype AtomicRepresentation = FWDebug.AtomicReferenceStorage<Self>
  override associatedtype AtomicOptionalRepresentation = FWDebug.AtomicOptionalReferenceStorage<Self>
}
@inlinable @inline(__always) internal var _concurrencyWindow: Swift.Int {
  get { 20 }
}
extension Swift.UnsafeMutablePointer where Pointee == FWDebug._AtomicReferenceStorage {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug.DoubleWord.AtomicRepresentation> {
    get {
    UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: DoubleWord.AtomicRepresentation.self)
  }
  }
}
@usableFromInline
internal struct _AtomicReferenceStorage {
  @usableFromInline
  internal init(_ value: __owned Swift.AnyObject?)
  @usableFromInline
  internal func dispose() -> Swift.AnyObject?
  @usableFromInline
  internal static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<FWDebug._AtomicReferenceStorage>) -> Swift.AnyObject?
  @usableFromInline
  internal static func atomicExchange(_ desired: __owned Swift.AnyObject?, at pointer: Swift.UnsafeMutablePointer<FWDebug._AtomicReferenceStorage>) -> Swift.AnyObject?
  @usableFromInline
  internal static func atomicCompareExchange(expected: Swift.AnyObject?, desired: __owned Swift.AnyObject?, at pointer: Swift.UnsafeMutablePointer<FWDebug._AtomicReferenceStorage>) -> (exchanged: Swift.Bool, original: Swift.AnyObject?)
}
@frozen public struct AtomicReferenceStorage<Value> where Value : AnyObject {
  @usableFromInline
  internal var _storage: FWDebug._AtomicReferenceStorage
  @inlinable public init(_ value: __owned Value) {
    _storage = .init(value)
  }
  @inlinable public func dispose() -> Value {
    return unsafeDowncast(_storage.dispose()!, to: Value.self)
  }
}
extension FWDebug.AtomicReferenceStorage {
  @inlinable @inline(__always) @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<FWDebug.AtomicReferenceStorage<Value>>) -> Swift.UnsafeMutablePointer<FWDebug._AtomicReferenceStorage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _AtomicReferenceStorage.self)
  }
}
extension FWDebug.AtomicReferenceStorage : FWDebug.AtomicStorage {
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicReferenceStorage<Value>>, ordering: FWDebug.AtomicLoadOrdering) -> Value {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicLoad(at: Self._extract(pointer))
    return unsafeDowncast(result!, to: Value.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicStore(_ desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicReferenceStorage<Value>>, ordering: FWDebug.AtomicStoreOrdering) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    _ = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicExchange(_ desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicReferenceStorage<Value>>, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
    return unsafeDowncast(result!, to: Value.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Value, desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicReferenceStorage<Value>>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    return (result.exchanged, unsafeDowncast(result.original!, to: Value.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Value, desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicReferenceStorage<Value>>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    return (result.exchanged, unsafeDowncast(result.original!, to: Value.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicWeakCompareExchange(expected: Value, desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicReferenceStorage<Value>>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    return (result.exchanged, unsafeDowncast(result.original!, to: Value.self))
  }
}
@frozen public struct AtomicOptionalReferenceStorage<Instance> where Instance : AnyObject {
  @usableFromInline
  internal var _storage: FWDebug._AtomicReferenceStorage
  @inlinable public init(_ value: __owned Instance?) {
    _storage = .init(value)
  }
  @inlinable public func dispose() -> Instance? {
    guard let value = _storage.dispose() else { return nil }
    return unsafeDowncast(value, to: Instance.self)
  }
}
extension FWDebug.AtomicOptionalReferenceStorage {
  @inlinable @inline(__always) @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<FWDebug.AtomicOptionalReferenceStorage<Instance>>) -> Swift.UnsafeMutablePointer<FWDebug._AtomicReferenceStorage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _AtomicReferenceStorage.self)
  }
}
extension FWDebug.AtomicOptionalReferenceStorage : FWDebug.AtomicStorage {
  public typealias Value = Instance?
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicOptionalReferenceStorage<Instance>>, ordering: FWDebug.AtomicLoadOrdering) -> Instance? {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicLoad(at: Self._extract(pointer))
    guard let r = result else { return nil }
    return unsafeDowncast(r, to: Instance.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicStore(_ desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicOptionalReferenceStorage<Instance>>, ordering: FWDebug.AtomicStoreOrdering) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    _ = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicExchange(_ desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicOptionalReferenceStorage<Instance>>, ordering: FWDebug.AtomicUpdateOrdering) -> Instance? {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
    guard let r = result else { return nil }
    return unsafeDowncast(r, to: Instance.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Instance?, desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicOptionalReferenceStorage<Instance>>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Instance?) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    guard let original = result.original else { return (result.exchanged, nil) }
    return (result.exchanged, unsafeDowncast(original, to: Instance.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Instance?, desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicOptionalReferenceStorage<Instance>>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Instance?) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    guard let original = result.original else { return (result.exchanged, nil) }
    return (result.exchanged, unsafeDowncast(original, to: Instance.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicWeakCompareExchange(expected: Instance?, desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<FWDebug.AtomicOptionalReferenceStorage<Instance>>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Instance?) {
    // FIXME: All orderings are treated as acquiring-and-releasing.
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    guard let original = result.original else { return (result.exchanged, nil) }
    return (result.exchanged, unsafeDowncast(original, to: Instance.self))
  }
}
public protocol AtomicValue {
  associatedtype AtomicRepresentation : FWDebug.AtomicStorage where Self == Self.AtomicRepresentation.Value
}
public protocol AtomicStorage {
  associatedtype Value
  init(_ value: __owned Self.Value)
  __consuming func dispose() -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicLoadOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicStore(_ desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicStoreOrdering)
  @_semantics("atomics.requires_constant_orderings") static func atomicExchange(_ desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Self.Value)
  @_semantics("atomics.requires_constant_orderings") static func atomicCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Self.Value)
  @_semantics("atomics.requires_constant_orderings") static func atomicWeakCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Self.Value)
}
public struct ClassDescriptor : FWDebug.TypeContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var superclass: Swift.UnsafeRawPointer {
    get
  }
  public var negativeSize: Swift.Int {
    get
  }
  public var positiveSize: Swift.Int {
    get
  }
  public var numMembers: Swift.Int {
    get
  }
  public var numFields: Swift.Int {
    get
  }
  public var fieldOffsetVectorOffset: Swift.Int {
    get
  }
  public var resilientSuperclass: Swift.UnsafeRawPointer? {
    get
  }
  public var foreignMetadataInitialization: FWDebug.ForeignMetadataInitialization? {
    get
  }
  public var singletonMetadataInitialization: FWDebug.SingletonMetadataInitialization? {
    get
  }
  public var vtableHeader: FWDebug.VTableDescriptorHeader? {
    get
  }
  public var methodDescriptors: [FWDebug.MethodDescriptor] {
    get
  }
  public var overrideTableHeader: FWDebug.OverrideTableHeader? {
    get
  }
  public var methodOverrideDescriptors: [FWDebug.MethodOverrideDescriptor] {
    get
  }
}
extension FWDebug.ClassDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.ClassDescriptor, b: FWDebug.ClassDescriptor) -> Swift.Bool
}
public struct VTableDescriptorHeader {
  public var offset: Swift.Int {
    get
  }
  public var size: Swift.Int {
    get
  }
}
public struct MethodDescriptor {
  public var flags: FWDebug.MethodDescriptor.Flags {
    get
  }
}
public struct OverrideTableHeader {
  public var numEntries: Swift.Int {
    get
  }
}
public struct MethodOverrideDescriptor {
  public var `class`: any FWDebug.ContextDescriptor {
    get
  }
  public var method: FWDebug.MethodDescriptor {
    get
  }
}
public struct MetadataBounds {
  public var negativeSize: Swift.Int {
    get
  }
  public var positiveSize: Swift.Int {
    get
  }
}
public struct ClassMetadata : FWDebug.TypeMetadata {
  public let ptr: Swift.UnsafeRawPointer
  public var descriptor: FWDebug.ClassDescriptor {
    get
  }
  public var isaPointer: Swift.UnsafeRawPointer? {
    get
  }
  public var superclassType: (any Any.Type)? {
    get
  }
  public var superclassMetadata: FWDebug.ClassMetadata? {
    get
  }
  public var classAddressPoint: Swift.Int {
    get
  }
  public var flags: FWDebug.ClassMetadata.Flags {
    get
  }
  public var classSize: Swift.Int {
    get
  }
  public var isSwiftClass: Swift.Bool {
    get
  }
  public var instanceAddressPoint: Swift.Int {
    get
  }
  public var instanceSize: Swift.Int {
    get
  }
  public var instanceAlignmentMask: Swift.Int {
    get
  }
  public var fieldOffsets: [Swift.Int] {
    get
  }
}
extension FWDebug.ClassMetadata : Swift.Equatable {
  public static func == (a: FWDebug.ClassMetadata, b: FWDebug.ClassMetadata) -> Swift.Bool
}
public struct ConformanceDescriptor {
  public var flags: FWDebug.ConformanceDescriptor.Flags {
    get
  }
  public var `protocol`: FWDebug.ProtocolDescriptor {
    get
  }
  public var contextDescriptor: (any FWDebug.TypeContextDescriptor)? {
    get
  }
  public var objcClass: FWDebug.ObjCClassWrapperMetadata? {
    get
  }
  public var witnessTablePattern: FWDebug.WitnessTable {
    get
  }
}
public protocol ContextDescriptor {
  var ptr: Swift.UnsafeRawPointer { get }
}
extension FWDebug.ContextDescriptor {
  public var flags: FWDebug.ContextDescriptorFlags {
    get
  }
  public var parent: (any FWDebug.ContextDescriptor)? {
    get
  }
  public var genericContext: FWDebug.GenericContext? {
    get
  }
}
extension FWDebug.AnonymousDescriptor {
  public struct Flags {
    public let bits: Swift.UInt16
    public var hasMangledName: Swift.Bool {
      get
    }
  }
}
public enum ContextDescriptorKind : Swift.Int {
  case module
  case `extension`
  case anonymous
  case `protocol`
  case opaqueType
  case `class`
  case `struct`
  case `enum`
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct ContextDescriptorFlags {
  public let bits: Swift.UInt32
  public var kind: FWDebug.ContextDescriptorKind {
    get
  }
  public var isUnique: Swift.Bool {
    get
  }
  public var isGeneric: Swift.Bool {
    get
  }
  public var version: Swift.UInt8 {
    get
  }
}
extension FWDebug.FieldDescriptor {
  public enum Kind : Swift.UInt16 {
    case `struct`
    case `class`
    case `enum`
    case multiPayloadEnum
    case `protocol`
    case classProtocol
    case objcProtocol
    case objcClass
    public init?(rawValue: Swift.UInt16)
    public typealias RawValue = Swift.UInt16
    public var rawValue: Swift.UInt16 {
      get
    }
  }
}
extension FWDebug.FieldRecord {
  public struct Flags {
    public let bits: Swift.UInt32
    public var isIndirectCase: Swift.Bool {
      get
    }
    public var isVar: Swift.Bool {
      get
    }
  }
}
extension FWDebug.GenericMetadataPattern {
  public struct Flags {
    public let bits: Swift.UInt32
    public var hasExtraDataPattern: Swift.Bool {
      get
    }
    public var hasTrailingFlags: Swift.Bool {
      get
    }
    public var valueMetadataKind: FWDebug.MetadataKind {
      get
    }
    public var classHasImmediateMembersPattern: Swift.Bool {
      get
    }
  }
}
public enum GenericParameterKind : Swift.UInt8 {
  case type
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct GenericParameterDescriptor {
  public let bits: Swift.UInt8
  public var kind: FWDebug.GenericParameterKind {
    get
  }
  public var hasExtraArgument: Swift.Bool {
    get
  }
  public var hasKeyArgument: Swift.Bool {
    get
  }
}
public enum GenericRequirementKind : Swift.UInt8 {
  case `protocol`
  case sameType
  case baseClass
  case sameConformance
  case layout
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension FWDebug.GenericRequirementDescriptor {
  public struct Flags {
    public let bits: Swift.UInt32
    public var kind: FWDebug.GenericRequirementKind {
      get
    }
    public var hasExtraArgument: Swift.Bool {
      get
    }
    public var hasKeyArgument: Swift.Bool {
      get
    }
  }
}
public enum GenericRequirementLayoutKind : Swift.UInt32 {
  case `class`
  public init?(rawValue: Swift.UInt32)
  public typealias RawValue = Swift.UInt32
  public var rawValue: Swift.UInt32 {
    get
  }
}
extension FWDebug.MethodDescriptor {
  public struct Flags {
    public let bits: Swift.UInt32
    public var kind: FWDebug.MethodDescriptor.Kind {
      get
    }
    public var isInstance: Swift.Bool {
      get
    }
    public var isDynamic: Swift.Bool {
      get
    }
  }
}
extension FWDebug.MethodDescriptor {
  public enum Kind : Swift.UInt8 {
    case method
    case `init`
    case getter
    case setter
    case modifyCoroutine
    case readCoroutine
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension FWDebug.ProtocolDescriptor {
  public struct Flags {
    public let bits: Swift.UInt16
    public var hasClassConstraint: Swift.Bool {
      get
    }
    public var isResilient: Swift.Bool {
      get
    }
    public var specialProtocol: FWDebug.SpecialProtocol {
      get
    }
  }
}
extension FWDebug.ProtocolRequirement {
  public struct Flags {
    public let bits: Swift.UInt32
    public var kind: FWDebug.ProtocolRequirement.Kind {
      get
    }
    public var isInstance: Swift.Bool {
      get
    }
  }
}
extension FWDebug.ProtocolRequirement {
  public enum Kind : Swift.UInt8 {
    case baseProtocol
    case method
    case `init`
    case getter
    case setter
    case readCoroutine
    case modifyCoroutine
    case associatedTypeAccessFunction
    case associatedConformanceAccessFunction
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
public enum ReferenceStorageKind : Swift.String {
  case none
  case weak
  case unowned
  case unmanaged
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct TypeContextDescriptorFlags {
  public let bits: Swift.UInt64
  public var metadataInitKind: FWDebug.MetadataInitializationKind {
    get
  }
  public var hasImportInfo: Swift.Bool {
    get
  }
  public var resilientSuperclassRefKind: FWDebug.TypeReferenceKind {
    get
  }
  public var classAreImmediateMembersNegative: Swift.Bool {
    get
  }
  public var classHasResilientSuperclass: Swift.Bool {
    get
  }
  public var classHasOverrideTable: Swift.Bool {
    get
  }
  public var classHasVTable: Swift.Bool {
    get
  }
}
public enum MetadataInitializationKind : Swift.UInt16 {
  case none
  case singleton
  case foreign
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum TypeReferenceKind : Swift.UInt16 {
  case directTypeDescriptor
  case indirectTypeDescriptor
  case directObjCClass
  case indirectObjCClass
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
extension FWDebug.DoubleWord {
  @inlinable @inline(__always) public init(high: Swift.UInt, low: Swift.UInt) {
    self = _sa_dword_create(high, low)
  }
  @inlinable @inline(__always) public init(first: Swift.UInt, second: Swift.UInt) {
    self = _sa_dword_create(second, first)
  }
  @inlinable @inline(__always) public var high: Swift.UInt {
    get { _sa_dword_extract_high(self) }
    set { self = _sa_dword_create(newValue, low) }
  }
  @inlinable @inline(__always) public var low: Swift.UInt {
    get { _sa_dword_extract_low(self) }
    set { self = _sa_dword_create(high, newValue) }
  }
  @inlinable @inline(__always) public var first: Swift.UInt {
    get {
        return _sa_dword_extract_low(self)
    }
    set {
        self = _sa_dword_create(high, newValue)
    }
  }
  @inlinable @inline(__always) public var second: Swift.UInt {
    get {
        return _sa_dword_extract_high(self)
    }
    set {
        self = _sa_dword_create(newValue, low)
    }
  }
}
extension FWDebug.DoubleWord : Swift.Equatable {
  @inlinable public static func == (left: FWDebug.DoubleWord, right: FWDebug.DoubleWord) -> Swift.Bool {
    left.high == right.high && left.low == right.low
  }
}
extension FWDebug.DoubleWord : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(self.high)
    hasher.combine(self.low)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension FWDebug.DoubleWord : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public func reflect(_ type: any Any.Type) -> any FWDebug.Metadata
public func reflect(_ instance: Any) -> any FWDebug.Metadata
public func reflectClass(_ type: any Any.Type) -> FWDebug.ClassMetadata?
public func reflectClass(_ instance: Any) -> FWDebug.ClassMetadata?
public func reflectEnum(_ type: any Any.Type) -> FWDebug.EnumMetadata?
public func reflectEnum(_ instance: Any) -> FWDebug.EnumMetadata?
public func reflectStruct(_ type: any Any.Type) -> FWDebug.StructMetadata?
public func reflectStruct(_ instance: Any) -> FWDebug.StructMetadata?
public func container(for instance: Any) -> FWDebug.AnyExistentialContainer
extension FWDebug.FieldRecord : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct EnumDescriptor : FWDebug.TypeContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var numPayloadCases: Swift.Int {
    get
  }
  public var payloadSizeOffset: Swift.Int {
    get
  }
  public var hasPayloadSizeOffset: Swift.Bool {
    get
  }
  public var numEmptyCases: Swift.Int {
    get
  }
  public var numCases: Swift.Int {
    get
  }
  public var foreignMetadataInitialization: FWDebug.ForeignMetadataInitialization? {
    get
  }
  public var singletonMetadataInitialization: FWDebug.SingletonMetadataInitialization? {
    get
  }
}
extension FWDebug.EnumDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.EnumDescriptor, b: FWDebug.EnumDescriptor) -> Swift.Bool
}
public struct EnumMetadata : FWDebug.TypeMetadata {
  public let ptr: Swift.UnsafeRawPointer
  public var descriptor: FWDebug.EnumDescriptor {
    get
  }
}
extension FWDebug.EnumMetadata : Swift.Equatable {
  public static func == (a: FWDebug.EnumMetadata, b: FWDebug.EnumMetadata) -> Swift.Bool
}
public struct EnumValueWitnessTable {
  public var vwt: FWDebug.ValueWitnessTable {
    get
  }
  public func getEnumTag(for instance: Swift.UnsafeRawPointer) -> Swift.UInt32
  public func destructiveProjectEnumData(for instance: Swift.UnsafeMutableRawPointer)
  public func destructiveInjectEnumTag(for instance: Swift.UnsafeMutableRawPointer, tag: Swift.UInt32)
}
public struct AnyExistentialContainer {
  public var data: (Swift.Int, Swift.Int, Swift.Int)
  public var type: any Any.Type
  public var metadata: any FWDebug.Metadata {
    get
  }
  public init(type: any Any.Type)
  public init(metadata: any FWDebug.Metadata)
  public mutating func projectValue() -> Swift.UnsafeRawPointer
}
public struct ExistentialContainer {
  public var base: FWDebug.AnyExistentialContainer
  public var witnessTable: FWDebug.WitnessTable
}
public struct DualExistentialContainer {
  public var base: FWDebug.AnyExistentialContainer
  public var witnessTables: (FWDebug.WitnessTable, FWDebug.WitnessTable)
}
public struct ExistentialMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var flags: FWDebug.ExistentialMetadata.Flags {
    get
  }
  public var numProtocols: Swift.Int {
    get
  }
  public var superclass: (any Any.Type)? {
    get
  }
  public var superclassMetadata: (any FWDebug.Metadata)? {
    get
  }
  public var protocols: [FWDebug.ProtocolDescriptor] {
    get
  }
}
extension FWDebug.ExistentialMetadata : Swift.Equatable {
  public static func == (a: FWDebug.ExistentialMetadata, b: FWDebug.ExistentialMetadata) -> Swift.Bool
}
public struct ExistentialMetatypeMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var instanceType: any Any.Type {
    get
  }
  public var instanceMetadata: FWDebug.ExistentialMetadata {
    get
  }
  public var flags: FWDebug.ExistentialMetadata.Flags {
    get
  }
}
extension FWDebug.ExistentialMetatypeMetadata : Swift.Equatable {
  public static func == (a: FWDebug.ExistentialMetatypeMetadata, b: FWDebug.ExistentialMetatypeMetadata) -> Swift.Bool
}
public struct ExtensionDescriptor : FWDebug.ContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var extendedContext: Swift.UnsafeRawPointer {
    get
  }
}
extension FWDebug.ExtensionDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.ExtensionDescriptor, b: FWDebug.ExtensionDescriptor) -> Swift.Bool
}
public struct FieldDescriptor {
  public var hasMangledTypeName: Swift.Bool {
    get
  }
  public var mangledTypeName: Swift.UnsafeRawPointer {
    get
  }
  public var superclass: Swift.UnsafeRawPointer {
    get
  }
  public var kind: FWDebug.FieldDescriptor.Kind {
    get
  }
  public var recordSize: Swift.Int {
    get
  }
  public var numFields: Swift.Int {
    get
  }
  public var records: [FWDebug.FieldRecord] {
    get
  }
}
public struct FieldRecord {
  public var flags: FWDebug.FieldRecord.Flags {
    get
  }
  public var hasMangledTypeName: Swift.Bool {
    get
  }
  public var mangledTypeName: Swift.UnsafeRawPointer {
    get
  }
  public var name: Swift.String {
    get
  }
  public var referenceStorage: FWDebug.ReferenceStorageKind {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(FLEXSwiftIvar) public class SwiftIvar : FWDebug.FLEXIvar {
  @objc override dynamic public var name: Swift.String {
    @objc get
  }
  @objc override dynamic public var type: FWDebug.FLEXTypeEncoding {
    @objc get
  }
  @objc override dynamic public var typeEncoding: Swift.String {
    @objc get
  }
  @objc override dynamic public var offset: Swift.Int {
    @objc get
  }
  @objc override dynamic public var size: Swift.UInt {
    @objc get
  }
  @objc override dynamic public var imagePath: Swift.String? {
    @objc get
  }
  @objc override dynamic public var details: Swift.String {
    @objc get
  }
  @objc override dynamic public func description() -> Swift.String!
  @objc override dynamic public func getValue(_ target: Any) -> Any?
  @objc override dynamic public func setValue(_ value: Any?, on target: Any)
  @objc override dynamic public func getPotentiallyUnboxedValue(_ target: Any) -> Any?
  @objc override dynamic public func auxiliaryInfo(forKey key: Swift.String) -> Any?
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(FLEXSwiftProtocol) public class SwiftProtocol : FWDebug.FLEXProtocol {
  @objc override dynamic public var name: Swift.String {
    @objc get
  }
  @objc override dynamic public var objc_protocol: FWDebug.`Protocol` {
    @objc get
  }
  @objc override dynamic public var imagePath: Swift.String? {
    @objc get
  }
  @objc override dynamic public var protocols: [FWDebug.FLEXProtocol] {
    @objc get
  }
  @objc override dynamic public var requiredMethods: [FWDebug.FLEXMethodDescription] {
    @objc get
  }
  @objc override dynamic public var optionalMethods: [FWDebug.FLEXMethodDescription] {
    @objc get
  }
  @objc override dynamic public var requiredProperties: [FWDebug.FLEXProperty] {
    @objc get
  }
  @objc override dynamic public var optionalProperties: [FWDebug.FLEXProperty] {
    @objc get
  }
  @objc deinit
}
@objc(FLEXSwiftMirror) public class SwiftMirror : ObjectiveC.NSObject, FWDebug.FLEXMirrorProtocol {
  @objc final public let value: Any
  @objc final public let isClass: Swift.Bool
  @objc final public let className: Swift.String
  @objc public var properties: [FWDebug.FLEXProperty] {
    get
  }
  @objc public var classProperties: [FWDebug.FLEXProperty] {
    get
  }
  @objc public var ivars: [FWDebug.FLEXIvar] {
    get
  }
  @objc public var methods: [FWDebug.FLEXMethod] {
    get
  }
  @objc public var classMethods: [FWDebug.FLEXMethod] {
    get
  }
  @objc public var protocols: [FWDebug.FLEXProtocol] {
    get
  }
  @objc public var superMirror: (any FWDebug.FLEXMirrorProtocol)? {
    @objc get
  }
  @objc required public init(reflecting objectOrClass: Any)
  @objc deinit
}
public struct ForeignClassMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
}
extension FWDebug.ForeignClassMetadata : Swift.Equatable {
  public static func == (a: FWDebug.ForeignClassMetadata, b: FWDebug.ForeignClassMetadata) -> Swift.Bool
}
public struct FunctionMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var flags: FWDebug.FunctionMetadata.Flags {
    get
  }
  public var resultType: any Any.Type {
    get
  }
  public var resultMetadata: any FWDebug.Metadata {
    get
  }
  public var paramTypes: [any Any.Type] {
    get
  }
  public var paramMetadata: [any FWDebug.Metadata] {
    get
  }
  public var paramFlags: [FWDebug.FunctionMetadata.ParamFlags] {
    get
  }
}
extension FWDebug.FunctionMetadata : Swift.Equatable {
  public static func == (a: FWDebug.FunctionMetadata, b: FWDebug.FunctionMetadata) -> Swift.Bool
}
public struct BoxPair {
  public let heapObj: Swift.UnsafePointer<FWDebug.HeapObject>
  public let buffer: Swift.UnsafeRawPointer
}
@_silgen_name("swift_allocBox")
public func swift_allocBox(for type: any Any.Type) -> FWDebug.BoxPair
public func swift_allocBox(for metadata: any FWDebug.Metadata) -> FWDebug.BoxPair
public func swift_allocObject(for type: FWDebug.ClassMetadata, size: Swift.Int, alignment: Swift.Int) -> Swift.UnsafeRawPointer
public func swift_getTypeName(for type: any Any.Type, qualified: Swift.Bool) -> Swift.String
public func swift_getTypeName(for metadata: any FWDebug.Metadata, qualified: Swift.Bool) -> Swift.String
public func swift_conformsToProtocol(type: any Any.Type, protocol: FWDebug.ProtocolDescriptor) -> FWDebug.WitnessTable?
public func swift_conformsToProtocol(metadata: any FWDebug.Metadata, protocol: FWDebug.ProtocolDescriptor) -> FWDebug.WitnessTable?
public struct GenericContext {
  public var numParams: Swift.Int {
    get
  }
  public var numRequirements: Swift.Int {
    get
  }
  public var numKeyArguments: Swift.Int {
    get
  }
  public var numExtraArguments: Swift.Int {
    get
  }
  public var parameters: [FWDebug.GenericParameterDescriptor] {
    get
  }
  public var requirements: [FWDebug.GenericRequirementDescriptor] {
    get
  }
  public var size: Swift.Int {
    get
  }
}
public struct GenericRequirementDescriptor {
  public var flags: FWDebug.GenericRequirementDescriptor.Flags {
    get
  }
  public var paramMangledName: Swift.UnsafeRawPointer {
    get
  }
  public var mangledTypeName: Swift.UnsafeRawPointer {
    get
  }
  public var `protocol`: FWDebug.ProtocolDescriptor {
    get
  }
  public var layoutKind: FWDebug.GenericRequirementLayoutKind {
    get
  }
}
public struct TypeGenericContext {
  public var numParams: Swift.Int {
    get
  }
  public var numRequirements: Swift.Int {
    get
  }
  public var numKeyArguments: Swift.Int {
    get
  }
  public var numExtraArguments: Swift.Int {
    get
  }
  public var parameters: [FWDebug.GenericParameterDescriptor] {
    get
  }
  public var requirements: [FWDebug.GenericRequirementDescriptor] {
    get
  }
  public var genericMetadataPattern: FWDebug.GenericMetadataPattern {
    get
  }
  public var size: Swift.Int {
    get
  }
}
public struct GenericMetadataPattern {
  public var flags: FWDebug.GenericMetadataPattern.Flags {
    get
  }
}
public struct HeapGenericLocalVariableMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var offset: Swift.Int {
    get
  }
  public var boxedType: any Any.Type {
    get
  }
  public var boxedMetadata: any FWDebug.Metadata {
    get
  }
}
extension FWDebug.HeapGenericLocalVariableMetadata : Swift.Equatable {
  public static func == (a: FWDebug.HeapGenericLocalVariableMetadata, b: FWDebug.HeapGenericLocalVariableMetadata) -> Swift.Bool
}
public struct HeapLocalVariableMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var offsetToFirstCapture: Swift.Int {
    get
  }
  public var captureDescription: Swift.UnsafePointer<Swift.CChar> {
    get
  }
}
extension FWDebug.HeapLocalVariableMetadata : Swift.Equatable {
  public static func == (a: FWDebug.HeapLocalVariableMetadata, b: FWDebug.HeapLocalVariableMetadata) -> Swift.Bool
}
public struct HeapObject {
  public let type: any Any.Type
  public var metadata: any FWDebug.Metadata {
    get
  }
}
@frozen public struct UnsafeAtomic<Value> where Value : FWDebug.AtomicValue {
  public typealias Storage = Value.AtomicRepresentation
  @usableFromInline
  internal let _ptr: Swift.UnsafeMutablePointer<FWDebug.UnsafeAtomic<Value>.Storage>
  @_transparent public init(@_nonEphemeral at pointer: Swift.UnsafeMutablePointer<FWDebug.UnsafeAtomic<Value>.Storage>) {
    self._ptr = pointer
  }
  @inlinable public static func create(_ initialValue: __owned Value) -> FWDebug.UnsafeAtomic<Value> {
    let ptr = UnsafeMutablePointer<Storage>.allocate(capacity: 1)
    ptr.initialize(to: Storage(initialValue))
    return Self(at: ptr)
  }
  @discardableResult
  @inlinable public func destroy() -> Value {
    let result = _ptr.pointee.dispose()
    _ptr.deinitialize(count: 1)
    _ptr.deallocate()
    return result
  }
}
extension FWDebug.UnsafeAtomic : @unchecked Swift.Sendable where Value : Swift.Sendable {
}
@_fixed_layout public class ManagedAtomic<Value> where Value : FWDebug.AtomicValue {
  @usableFromInline
  internal var _storage: Value.AtomicRepresentation
  @inline(__always) @_alwaysEmitIntoClient public init(_ value: Value) {
    _storage = Value.AtomicRepresentation(value)
  }
  @objc deinit
  @_alwaysEmitIntoClient @inline(__always) internal var _ptr: Swift.UnsafeMutablePointer<Value.AtomicRepresentation> {
    get {
    _getUnsafePointerToStoredProperties(self)
      .assumingMemoryBound(to: Value.AtomicRepresentation.self)
  }
  }
}
extension FWDebug.UnsafeAtomic {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func load(ordering: FWDebug.AtomicLoadOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoad(at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func store(_ desired: __owned Value, ordering: FWDebug.AtomicStoreOrdering) {
    Value.AtomicRepresentation.atomicStore(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func exchange(_ desired: __owned Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicExchange(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    Value.AtomicRepresentation.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    Value.AtomicRepresentation.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func weakCompareExchange(expected: Value, desired: __owned Value, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    Value.AtomicRepresentation.atomicWeakCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
}
extension FWDebug.UnsafeAtomic where Value : FWDebug.AtomicInteger {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingIncrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingDecrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseAnd(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseOr(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseXor(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrementThenLoad(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &+ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrementThenLoad(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &- operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseAndThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original & operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseOrThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original | operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseXorThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original ^ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) {
    _ = Value.AtomicRepresentation.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) {
    _ = Value.AtomicRepresentation.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
}
extension FWDebug.ManagedAtomic {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func load(ordering: FWDebug.AtomicLoadOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoad(at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func store(_ desired: __owned Value, ordering: FWDebug.AtomicStoreOrdering) {
    Value.AtomicRepresentation.atomicStore(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func exchange(_ desired: __owned Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicExchange(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    Value.AtomicRepresentation.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    Value.AtomicRepresentation.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func weakCompareExchange(expected: Value, desired: __owned Value, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    Value.AtomicRepresentation.atomicWeakCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
}
extension FWDebug.ManagedAtomic where Value : FWDebug.AtomicInteger {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingIncrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingDecrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseAnd(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseOr(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseXor(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrementThenLoad(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &+ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrementThenLoad(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &- operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseAndThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original & operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseOrThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original | operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseXorThenLoad(with operand: Value, ordering: FWDebug.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original ^ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) {
    _ = Value.AtomicRepresentation.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrement(by operand: Value = 1, ordering: FWDebug.AtomicUpdateOrdering) {
    _ = Value.AtomicRepresentation.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
}
public var protocols: [FWDebug.ProtocolDescriptor] {
  get
}
public var types: [any FWDebug.ContextDescriptor] {
  get
}
extension Swift.Int : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int
    @usableFromInline
    internal var _storage: FWDebug._AtomicIntStorage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Int.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_Int(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Int.AtomicRepresentation.Value {
      return _sa_dispose_Int(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicIntStorage> {
    get {
    // `Int` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicIntStorage.self)
  }
  }
}
extension Swift.Int.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Int.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_Int(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_Int(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_Int(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_Int(pointer._extract, desired)
    case .releasing:
      _sa_store_release_Int(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_Int(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_Int(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_Int(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_Int(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_Int(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_Int(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int.AtomicRepresentation.Value, desired: Swift.Int.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int.AtomicRepresentation.Value, desired: Swift.Int.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int.AtomicRepresentation.Value, desired: Swift.Int.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_Int(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_Int(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.Int : FWDebug.AtomicInteger {
}
extension Swift.Int.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_Int(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_Int(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_Int(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_Int(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_Int(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_Int(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_Int(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_Int(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_Int(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_Int(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_Int(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_Int(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_Int(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_Int(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_Int(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_Int(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_Int(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_Int(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_Int(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_Int(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_Int(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_Int(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_Int(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_Int(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_Int(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.Int64 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int64
    @usableFromInline
    internal var _storage: FWDebug._AtomicInt64Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Int64.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_Int64(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Int64.AtomicRepresentation.Value {
      return _sa_dispose_Int64(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int64.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicInt64Storage> {
    get {
    // `Int64` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicInt64Storage.self)
  }
  }
}
extension Swift.Int64.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Int64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_Int64(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_Int64(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_Int64(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_Int64(pointer._extract, desired)
    case .releasing:
      _sa_store_release_Int64(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_Int64(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_Int64(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_Int64(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_Int64(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_Int64(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_Int64(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int64.AtomicRepresentation.Value, desired: Swift.Int64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int64.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int64(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int64(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int64(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int64(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int64.AtomicRepresentation.Value, desired: Swift.Int64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int64.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int64.AtomicRepresentation.Value, desired: Swift.Int64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int64.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_Int64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int64(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.Int64 : FWDebug.AtomicInteger {
}
extension Swift.Int64.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_Int64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_Int64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_Int64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_Int64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_Int64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_Int64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_Int64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_Int64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_Int64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_Int64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_Int64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_Int64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_Int64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_Int64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_Int64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_Int64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_Int64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_Int64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_Int64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_Int64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_Int64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_Int64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_Int64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_Int64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_Int64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.Int32 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int32
    @usableFromInline
    internal var _storage: FWDebug._AtomicInt32Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Int32.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_Int32(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Int32.AtomicRepresentation.Value {
      return _sa_dispose_Int32(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int32.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicInt32Storage> {
    get {
    // `Int32` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicInt32Storage.self)
  }
  }
}
extension Swift.Int32.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Int32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_Int32(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_Int32(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_Int32(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_Int32(pointer._extract, desired)
    case .releasing:
      _sa_store_release_Int32(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_Int32(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_Int32(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_Int32(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_Int32(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_Int32(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_Int32(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int32.AtomicRepresentation.Value, desired: Swift.Int32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int32.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int32(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int32(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int32(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int32(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int32.AtomicRepresentation.Value, desired: Swift.Int32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int32.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int32.AtomicRepresentation.Value, desired: Swift.Int32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int32.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_Int32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int32(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.Int32 : FWDebug.AtomicInteger {
}
extension Swift.Int32.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_Int32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_Int32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_Int32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_Int32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_Int32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_Int32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_Int32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_Int32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_Int32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_Int32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_Int32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_Int32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_Int32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_Int32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_Int32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_Int32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_Int32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_Int32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_Int32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_Int32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_Int32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_Int32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_Int32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_Int32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_Int32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.Int16 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int16
    @usableFromInline
    internal var _storage: FWDebug._AtomicInt16Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Int16.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_Int16(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Int16.AtomicRepresentation.Value {
      return _sa_dispose_Int16(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int16.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicInt16Storage> {
    get {
    // `Int16` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicInt16Storage.self)
  }
  }
}
extension Swift.Int16.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Int16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_Int16(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_Int16(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_Int16(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_Int16(pointer._extract, desired)
    case .releasing:
      _sa_store_release_Int16(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_Int16(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_Int16(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_Int16(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_Int16(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_Int16(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_Int16(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int16.AtomicRepresentation.Value, desired: Swift.Int16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int16.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int16(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int16(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int16(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int16(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int16.AtomicRepresentation.Value, desired: Swift.Int16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int16.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int16.AtomicRepresentation.Value, desired: Swift.Int16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int16.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_Int16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int16(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.Int16 : FWDebug.AtomicInteger {
}
extension Swift.Int16.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_Int16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_Int16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_Int16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_Int16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_Int16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_Int16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_Int16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_Int16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_Int16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_Int16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_Int16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_Int16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_Int16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_Int16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_Int16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_Int16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_Int16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_Int16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_Int16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_Int16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_Int16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_Int16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_Int16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_Int16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_Int16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.Int8 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int8
    @usableFromInline
    internal var _storage: FWDebug._AtomicInt8Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Int8.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_Int8(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Int8.AtomicRepresentation.Value {
      return _sa_dispose_Int8(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int8.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicInt8Storage> {
    get {
    // `Int8` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicInt8Storage.self)
  }
  }
}
extension Swift.Int8.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Int8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_Int8(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_Int8(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_Int8(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_Int8(pointer._extract, desired)
    case .releasing:
      _sa_store_release_Int8(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_Int8(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_Int8(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_Int8(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_Int8(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_Int8(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_Int8(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int8.AtomicRepresentation.Value, desired: Swift.Int8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int8.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int8(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int8(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int8(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int8(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int8.AtomicRepresentation.Value, desired: Swift.Int8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int8.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int8.AtomicRepresentation.Value, desired: Swift.Int8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int8.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_Int8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_Int8(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.Int8 : FWDebug.AtomicInteger {
}
extension Swift.Int8.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_Int8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_Int8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_Int8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_Int8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_Int8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_Int8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_Int8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_Int8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_Int8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_Int8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_Int8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_Int8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_Int8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_Int8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_Int8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_Int8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_Int8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_Int8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_Int8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_Int8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Int8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_Int8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_Int8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_Int8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_Int8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_Int8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.UInt : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt
    @usableFromInline
    internal var _storage: FWDebug._AtomicUIntStorage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UInt.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_UInt(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UInt.AtomicRepresentation.Value {
      return _sa_dispose_UInt(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicUIntStorage> {
    get {
    // `UInt` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicUIntStorage.self)
  }
  }
}
extension Swift.UInt.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UInt.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_UInt(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_UInt(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_UInt(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_UInt(pointer._extract, desired)
    case .releasing:
      _sa_store_release_UInt(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_UInt(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_UInt(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_UInt(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_UInt(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_UInt(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_UInt(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt.AtomicRepresentation.Value, desired: Swift.UInt.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt.AtomicRepresentation.Value, desired: Swift.UInt.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt.AtomicRepresentation.Value, desired: Swift.UInt.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_UInt(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.UInt : FWDebug.AtomicInteger {
}
extension Swift.UInt.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_UInt(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_UInt(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_UInt(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_UInt(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_UInt(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_UInt(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_UInt(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_UInt(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_UInt(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_UInt(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_UInt(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_UInt(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_UInt(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_UInt(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_UInt(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_UInt(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_UInt(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_UInt(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_UInt(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_UInt(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_UInt(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_UInt(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_UInt(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_UInt(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_UInt(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.UInt64 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt64
    @usableFromInline
    internal var _storage: FWDebug._AtomicUInt64Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UInt64.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_UInt64(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UInt64.AtomicRepresentation.Value {
      return _sa_dispose_UInt64(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt64.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicUInt64Storage> {
    get {
    // `UInt64` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicUInt64Storage.self)
  }
  }
}
extension Swift.UInt64.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UInt64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_UInt64(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_UInt64(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_UInt64(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_UInt64(pointer._extract, desired)
    case .releasing:
      _sa_store_release_UInt64(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_UInt64(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_UInt64(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_UInt64(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_UInt64(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_UInt64(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_UInt64(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt64.AtomicRepresentation.Value, desired: Swift.UInt64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt64.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt64(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt64(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt64(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt64(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt64.AtomicRepresentation.Value, desired: Swift.UInt64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt64.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt64.AtomicRepresentation.Value, desired: Swift.UInt64.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt64.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_UInt64(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt64(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.UInt64 : FWDebug.AtomicInteger {
}
extension Swift.UInt64.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_UInt64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_UInt64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_UInt64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_UInt64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_UInt64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_UInt64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_UInt64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_UInt64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_UInt64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_UInt64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_UInt64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_UInt64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_UInt64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_UInt64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_UInt64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_UInt64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_UInt64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_UInt64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_UInt64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_UInt64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt64.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt64.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_UInt64(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_UInt64(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_UInt64(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_UInt64(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_UInt64(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.UInt32 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt32
    @usableFromInline
    internal var _storage: FWDebug._AtomicUInt32Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UInt32.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_UInt32(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UInt32.AtomicRepresentation.Value {
      return _sa_dispose_UInt32(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt32.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicUInt32Storage> {
    get {
    // `UInt32` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicUInt32Storage.self)
  }
  }
}
extension Swift.UInt32.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UInt32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_UInt32(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_UInt32(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_UInt32(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_UInt32(pointer._extract, desired)
    case .releasing:
      _sa_store_release_UInt32(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_UInt32(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_UInt32(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_UInt32(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_UInt32(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_UInt32(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_UInt32(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt32.AtomicRepresentation.Value, desired: Swift.UInt32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt32.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt32(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt32(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt32(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt32(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt32.AtomicRepresentation.Value, desired: Swift.UInt32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt32.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt32.AtomicRepresentation.Value, desired: Swift.UInt32.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt32.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_UInt32(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt32(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.UInt32 : FWDebug.AtomicInteger {
}
extension Swift.UInt32.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_UInt32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_UInt32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_UInt32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_UInt32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_UInt32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_UInt32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_UInt32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_UInt32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_UInt32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_UInt32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_UInt32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_UInt32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_UInt32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_UInt32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_UInt32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_UInt32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_UInt32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_UInt32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_UInt32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_UInt32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt32.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt32.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_UInt32(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_UInt32(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_UInt32(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_UInt32(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_UInt32(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.UInt16 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt16
    @usableFromInline
    internal var _storage: FWDebug._AtomicUInt16Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UInt16.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_UInt16(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UInt16.AtomicRepresentation.Value {
      return _sa_dispose_UInt16(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt16.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicUInt16Storage> {
    get {
    // `UInt16` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicUInt16Storage.self)
  }
  }
}
extension Swift.UInt16.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UInt16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_UInt16(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_UInt16(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_UInt16(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_UInt16(pointer._extract, desired)
    case .releasing:
      _sa_store_release_UInt16(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_UInt16(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_UInt16(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_UInt16(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_UInt16(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_UInt16(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_UInt16(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt16.AtomicRepresentation.Value, desired: Swift.UInt16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt16.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt16(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt16(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt16(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt16(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt16.AtomicRepresentation.Value, desired: Swift.UInt16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt16.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt16.AtomicRepresentation.Value, desired: Swift.UInt16.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt16.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_UInt16(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt16(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.UInt16 : FWDebug.AtomicInteger {
}
extension Swift.UInt16.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_UInt16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_UInt16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_UInt16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_UInt16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_UInt16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_UInt16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_UInt16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_UInt16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_UInt16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_UInt16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_UInt16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_UInt16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_UInt16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_UInt16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_UInt16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_UInt16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_UInt16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_UInt16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_UInt16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_UInt16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt16.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt16.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_UInt16(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_UInt16(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_UInt16(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_UInt16(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_UInt16(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension Swift.UInt8 : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt8
    @usableFromInline
    internal var _storage: FWDebug._AtomicUInt8Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UInt8.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_UInt8(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UInt8.AtomicRepresentation.Value {
      return _sa_dispose_UInt8(_storage)
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt8.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicUInt8Storage> {
    get {
    // `UInt8` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicUInt8Storage.self)
  }
  }
}
extension Swift.UInt8.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UInt8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_UInt8(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_UInt8(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_UInt8(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_UInt8(pointer._extract, desired)
    case .releasing:
      _sa_store_release_UInt8(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_UInt8(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_UInt8(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_UInt8(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_UInt8(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_UInt8(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_UInt8(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt8.AtomicRepresentation.Value, desired: Swift.UInt8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt8.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt8(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt8(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt8(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt8(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt8.AtomicRepresentation.Value, desired: Swift.UInt8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt8.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt8.AtomicRepresentation.Value, desired: Swift.UInt8.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt8.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_UInt8(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_UInt8(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
extension Swift.UInt8 : FWDebug.AtomicInteger {
}
extension Swift.UInt8.AtomicRepresentation : FWDebug.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_add_relaxed_UInt8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_add_acquire_UInt8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_add_release_UInt8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_add_acq_rel_UInt8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_add_seq_cst_UInt8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_sub_relaxed_UInt8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_sub_acquire_UInt8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_sub_release_UInt8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_sub_acq_rel_UInt8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_sub_seq_cst_UInt8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_and_relaxed_UInt8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_and_acquire_UInt8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_and_release_UInt8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_and_acq_rel_UInt8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_and_seq_cst_UInt8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_or_relaxed_UInt8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_or_acquire_UInt8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_or_release_UInt8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_or_acq_rel_UInt8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_or_seq_cst_UInt8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt8.AtomicRepresentation.Value = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UInt8.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_fetch_xor_relaxed_UInt8(
        pointer._extract,
        operand)
    case .acquiring:
      return _sa_fetch_xor_acquire_UInt8(
        pointer._extract,
        operand)
    case .releasing:
      return _sa_fetch_xor_release_UInt8(
        pointer._extract,
        operand)
    case .acquiringAndReleasing:
      return _sa_fetch_xor_acq_rel_UInt8(
        pointer._extract,
        operand)
    case .sequentiallyConsistent:
      return _sa_fetch_xor_seq_cst_UInt8(
        pointer._extract,
        operand)
    default:
      fatalError("Unsupported ordering")
    }
  }
}
extension FWDebug.DoubleWord : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = FWDebug.DoubleWord
    @usableFromInline
    internal var _storage: FWDebug._AtomicDoubleWordStorage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: FWDebug.DoubleWord.AtomicRepresentation.Value) {
      self._storage = _sa_prepare_DoubleWord(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> FWDebug.DoubleWord.AtomicRepresentation.Value {
      // Work around https://github.com/apple/swift-atomics/issues/41
      #if compiler(>=5.5) && arch(arm64) && DEBUG
      var copy = self // This is not great
      var expected = DoubleWord(high: 0, low: 0)
      withUnsafeMutablePointer(to: &copy) { pointer in
        _ = _sa_cmpxchg_strong_relaxed_relaxed_DoubleWord(
          pointer._extract,
          &expected,
          DoubleWord(high: 0, low: 0))
      }
      return expected
      #else
      return _sa_dispose_DoubleWord(_storage)
      #endif
    }
  }
}
extension Swift.UnsafeMutablePointer where Pointee == FWDebug.DoubleWord.AtomicRepresentation {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<FWDebug._AtomicDoubleWordStorage> {
    get {
    // `DoubleWord` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: _AtomicDoubleWordStorage.self)
  }
  }
}
extension FWDebug.DoubleWord.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<FWDebug.DoubleWord.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> FWDebug.DoubleWord.AtomicRepresentation.Value {
    // Work around https://github.com/apple/swift-atomics/issues/41
    #if compiler(>=5.5) && arch(arm64) && DEBUG
    let (_, original) = atomicCompareExchange(
      expected: DoubleWord(high: 0, low: 0),
      desired: DoubleWord(high: 0, low: 0),
      at: pointer,
      successOrdering: .relaxed, // Note: this relies on the FIXME below.
      failureOrdering: ordering)
    return original
    #else
    switch ordering {
    case .relaxed:
      return _sa_load_relaxed_DoubleWord(pointer._extract)
    case .acquiring:
      return _sa_load_acquire_DoubleWord(pointer._extract)
    case .sequentiallyConsistent:
      return _sa_load_seq_cst_DoubleWord(pointer._extract)
    default:
      fatalError("Unsupported ordering")
    }
    #endif
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: FWDebug.DoubleWord.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.DoubleWord.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      _sa_store_relaxed_DoubleWord(pointer._extract, desired)
    case .releasing:
      _sa_store_release_DoubleWord(pointer._extract, desired)
    case .sequentiallyConsistent:
      _sa_store_seq_cst_DoubleWord(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: FWDebug.DoubleWord.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.DoubleWord.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> FWDebug.DoubleWord.AtomicRepresentation.Value {
    switch ordering {
    case .relaxed:
      return _sa_exchange_relaxed_DoubleWord(pointer._extract, desired)
    case .acquiring:
      return _sa_exchange_acquire_DoubleWord(pointer._extract, desired)
    case .releasing:
      return _sa_exchange_release_DoubleWord(pointer._extract, desired)
    case .acquiringAndReleasing:
      return _sa_exchange_acq_rel_DoubleWord(pointer._extract, desired)
    case .sequentiallyConsistent:
      return _sa_exchange_seq_cst_DoubleWord(pointer._extract, desired)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: FWDebug.DoubleWord.AtomicRepresentation.Value, desired: FWDebug.DoubleWord.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.DoubleWord.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: FWDebug.DoubleWord.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    switch ordering {
    case .relaxed:
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_DoubleWord(
        pointer._extract,
        &expected, desired)
    case .acquiring:
      exchanged = _sa_cmpxchg_strong_acquire_acquire_DoubleWord(
        pointer._extract,
        &expected, desired)
    case .releasing:
      exchanged = _sa_cmpxchg_strong_release_relaxed_DoubleWord(
        pointer._extract,
        &expected, desired)
    case .acquiringAndReleasing:
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_DoubleWord(
        pointer._extract,
        &expected, desired)
    case .sequentiallyConsistent:
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected, desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: FWDebug.DoubleWord.AtomicRepresentation.Value, desired: FWDebug.DoubleWord.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.DoubleWord.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: FWDebug.DoubleWord.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_strong_relaxed_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_strong_acquire_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_strong_acquire_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_release_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_strong_acq_rel_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_strong_acq_rel_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_strong_seq_cst_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_strong_seq_cst_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_strong_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: FWDebug.DoubleWord.AtomicRepresentation.Value, desired: FWDebug.DoubleWord.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<FWDebug.DoubleWord.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: FWDebug.DoubleWord.AtomicRepresentation.Value) {
    var expected = expected
    let exchanged: Bool
    // FIXME: stdatomic.h (and LLVM underneath) doesn't support
    // arbitrary ordering combinations yet, so upgrade the success
    // ordering when necessary so that it is at least as "strong" as
    // the failure case.
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      exchanged = _sa_cmpxchg_weak_relaxed_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.relaxed, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .relaxed):
      exchanged = _sa_cmpxchg_weak_acquire_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .acquiring):
      exchanged = _sa_cmpxchg_weak_acquire_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiring, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_release_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.releasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .relaxed):
      exchanged = _sa_cmpxchg_weak_acq_rel_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .acquiring):
      exchanged = _sa_cmpxchg_weak_acq_rel_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .relaxed):
      exchanged = _sa_cmpxchg_weak_seq_cst_relaxed_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .acquiring):
      exchanged = _sa_cmpxchg_weak_seq_cst_acquire_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      exchanged = _sa_cmpxchg_weak_seq_cst_seq_cst_DoubleWord(
        pointer._extract,
        &expected,
        desired)
    default:
      fatalError("Unsupported ordering")
    }
    return (exchanged, expected)
  }
}
public enum KnownMetadata {
}
extension FWDebug.KnownMetadata {
  public enum Builtin {
  }
}
extension FWDebug.KnownMetadata.Builtin {
  public static var int1: FWDebug.OpaqueMetadata {
    get
  }
  public static var int7: FWDebug.OpaqueMetadata {
    get
  }
  public static var int8: FWDebug.OpaqueMetadata {
    get
  }
  public static var int16: FWDebug.OpaqueMetadata {
    get
  }
  public static var int32: FWDebug.OpaqueMetadata {
    get
  }
  public static var int64: FWDebug.OpaqueMetadata {
    get
  }
  public static var int128: FWDebug.OpaqueMetadata {
    get
  }
  public static var int256: FWDebug.OpaqueMetadata {
    get
  }
  public static var int512: FWDebug.OpaqueMetadata {
    get
  }
  public static var word: FWDebug.OpaqueMetadata {
    get
  }
  public static var fpiee16: FWDebug.OpaqueMetadata {
    get
  }
  public static var fpiee32: FWDebug.OpaqueMetadata {
    get
  }
  public static var fpiee64: FWDebug.OpaqueMetadata {
    get
  }
  public static var fpiee80: FWDebug.OpaqueMetadata {
    get
  }
  public static var fpiee128: FWDebug.OpaqueMetadata {
    get
  }
  public static var nativeObject: FWDebug.OpaqueMetadata {
    get
  }
  public static var bridgeObject: FWDebug.OpaqueMetadata {
    get
  }
  public static var rawPointer: FWDebug.OpaqueMetadata {
    get
  }
  public static var unsafeValueBuffer: FWDebug.OpaqueMetadata {
    get
  }
  public static var unknownObject: FWDebug.OpaqueMetadata {
    get
  }
}
public protocol Metadata {
  var ptr: Swift.UnsafeRawPointer { get }
}
extension FWDebug.Metadata {
  public var type: any Any.Type {
    get
  }
  public var vwt: FWDebug.ValueWitnessTable {
    get
  }
  public var enumVwt: FWDebug.EnumValueWitnessTable {
    get
  }
  public var kind: FWDebug.MetadataKind {
    get
  }
}
extension FWDebug.Metadata {
  public func allocateBoxForExistential(in container: Swift.UnsafeMutablePointer<FWDebug.AnyExistentialContainer>) -> Swift.UnsafeRawPointer
}
public struct MetadataAccessFunction {
  public func callAsFunction(_ request: FWDebug.MetadataRequest) -> FWDebug.MetadataResponse
  public func callAsFunction(_ request: FWDebug.MetadataRequest, _ args: any Any.Type...) -> FWDebug.MetadataResponse
  public func callAsFunction(_ request: FWDebug.MetadataRequest, _ args: (any Any.Type, FWDebug.WitnessTable?)...) -> FWDebug.MetadataResponse
}
public struct MetadataRequest {
  public var bits: Swift.Int
  public static var complete: FWDebug.MetadataRequest {
    get
  }
  public init(state: FWDebug.MetadataState, isNonBlocking: Swift.Bool = false)
  public var state: FWDebug.MetadataState {
    get
  }
  public var isNonBlocking: Swift.Bool {
    get
  }
}
public struct MetadataResponse {
  public let type: any Any.Type
  public var metadata: any FWDebug.Metadata {
    get
  }
  public var state: FWDebug.MetadataState {
    get
  }
}
public enum MetadataKind : Swift.Int {
  case `class`
  case `struct`
  case `enum`
  case optional
  case foreignClass
  case opaque
  case tuple
  case function
  case existential
  case metatype
  case objcClassWrapper
  case existentialMetatype
  case heapLocalVariable
  case heapGenericLocalVariable
  case errorObject
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MetadataState : Swift.UInt8 {
  case complete
  case nonTransitiveComplete
  case layoutComplete
  case abstract
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension FWDebug.ClassMetadata {
  public struct Flags {
    public let bits: Swift.UInt32
    public var isSwiftPreStableABI: Swift.Bool {
      get
    }
    public var usesSwiftRefCounting: Swift.Bool {
      get
    }
    public var hasCustomObjCName: Swift.Bool {
      get
    }
  }
}
extension FWDebug.ExistentialMetadata {
  public struct Flags {
    public let bits: Swift.UInt32
    public var numWitnessTables: Swift.Int {
      get
    }
    public var specialProtocol: FWDebug.SpecialProtocol {
      get
    }
    public var hasSuperclassConstraint: Swift.Bool {
      get
    }
    public var isClassConstraint: Swift.Bool {
      get
    }
  }
}
public enum SpecialProtocol : Swift.UInt8 {
  case none
  case error
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension FWDebug.FunctionMetadata {
  public struct Flags {
    public let bits: Swift.Int
    public var numParams: Swift.Int {
      get
    }
    public var convention: FWDebug.FunctionConvention {
      get
    }
    public var `throws`: Swift.Bool {
      get
    }
    public var hasParamFlags: Swift.Bool {
      get
    }
    public var isEscaping: Swift.Bool {
      get
    }
  }
}
public enum FunctionConvention : Swift.UInt8 {
  case swift
  case block
  case thin
  case c
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension FWDebug.FunctionMetadata {
  public struct ParamFlags {
    public let bits: Swift.UInt32
    public var valueOwnership: FWDebug.ValueOwnership {
      get
    }
    public var isVariadic: Swift.Bool {
      get
    }
    public var isAutoclosure: Swift.Bool {
      get
    }
  }
}
public enum ValueOwnership : Swift.UInt8 {
  case `default`
  case `inout`
  case shared
  case owned
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension FWDebug.ValueWitnessTable {
  public struct Flags {
    public let bits: Swift.UInt32
    public var alignment: Swift.Int {
      get
    }
    public var isValueInline: Swift.Bool {
      get
    }
    public var isPOD: Swift.Bool {
      get
    }
    public var isBitwiseTakable: Swift.Bool {
      get
    }
    public var hasEnumWitnesses: Swift.Bool {
      get
    }
    public var isIncomplete: Swift.Bool {
      get
    }
  }
}
public struct MetatypeMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var instanceType: any Any.Type {
    get
  }
  public var instanceMetadata: any FWDebug.Metadata {
    get
  }
}
extension FWDebug.MetatypeMetadata : Swift.Equatable {
  public static func == (a: FWDebug.MetatypeMetadata, b: FWDebug.MetatypeMetadata) -> Swift.Bool
}
public struct ModuleDescriptor : FWDebug.ContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var name: Swift.String {
    get
  }
}
extension FWDebug.ModuleDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.ModuleDescriptor, b: FWDebug.ModuleDescriptor) -> Swift.Bool
}
public struct ObjCClassWrapperMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var classType: any Any.Type {
    get
  }
  public var classMetadata: FWDebug.ClassMetadata {
    get
  }
  public var conformances: [FWDebug.ConformanceDescriptor] {
    get
  }
}
extension FWDebug.ObjCClassWrapperMetadata : Swift.Equatable {
  public static func == (a: FWDebug.ObjCClassWrapperMetadata, b: FWDebug.ObjCClassWrapperMetadata) -> Swift.Bool
}
public struct OpaqueDescriptor : FWDebug.ContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var numUnderlyingTypes: Swift.Int {
    get
  }
  public var underlyingTypeMangledNames: [Swift.UnsafeRawPointer] {
    get
  }
}
extension FWDebug.OpaqueDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.OpaqueDescriptor, b: FWDebug.OpaqueDescriptor) -> Swift.Bool
}
public struct OpaqueMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
}
extension FWDebug.OpaqueMetadata : Swift.Equatable {
  public static func == (a: FWDebug.OpaqueMetadata, b: FWDebug.OpaqueMetadata) -> Swift.Bool
}
extension Swift.UnsafeRawPointer : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafeRawPointer
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafeRawPointer.AtomicRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafeRawPointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
    return UnsafeRawPointer(bitPattern: bitPattern)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeRawPointer.AtomicRepresentation.Value) -> Swift.Int {
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafeRawPointer.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeMutableRawPointer : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafeMutableRawPointer
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
    return UnsafeMutableRawPointer(bitPattern: bitPattern)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) -> Swift.Int {
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafePointer : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafePointer<Pointee>
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafePointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
    return UnsafePointer(bitPattern: bitPattern)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) -> Swift.Int {
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafePointer.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeMutablePointer : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafeMutablePointer<Pointee>
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafeMutablePointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
    return UnsafeMutablePointer(bitPattern: bitPattern)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) -> Swift.Int {
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafeMutablePointer.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.Unmanaged : FWDebug.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Unmanaged<Instance>
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.Unmanaged<Instance>.AtomicRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.Unmanaged.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
    return Unmanaged.fromOpaque(UnsafeRawPointer(bitPattern: bitPattern)!)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) -> Swift.Int {
    return Int(bitPattern: value.toOpaque())
  }
}
extension Swift.Unmanaged.AtomicRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeRawPointer : FWDebug.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafeRawPointer?
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
    return UnsafeRawPointer(bitPattern: bitPattern)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) -> Swift.Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeMutableRawPointer : FWDebug.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafeMutableRawPointer?
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
    return UnsafeMutableRawPointer(bitPattern: bitPattern)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) -> Swift.Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafePointer : FWDebug.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafePointer<Pointee>?
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafePointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
    return UnsafePointer(bitPattern: bitPattern)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) -> Swift.Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafePointer.AtomicOptionalRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeMutablePointer : FWDebug.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafeMutablePointer<Pointee>?
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.UnsafeMutablePointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
    return UnsafeMutablePointer(bitPattern: bitPattern)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) -> Swift.Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}
extension Swift.UnsafeMutablePointer.AtomicOptionalRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.Unmanaged : FWDebug.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.Unmanaged<Instance>?
    @usableFromInline
    internal typealias Storage = Swift.Int.AtomicRepresentation
    @usableFromInline
    internal let _storage: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
      self._storage = .init(Self._encode(value))
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage.dispose())
    }
  }
}
extension Swift.Unmanaged.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ bitPattern: Swift.Int) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
    guard let opaque = UnsafeRawPointer(bitPattern: bitPattern) else {
      return nil
    }
    return Unmanaged.fromOpaque(opaque)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) -> Swift.Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value.toOpaque())
  }
}
extension Swift.Unmanaged.AtomicOptionalRepresentation : FWDebug.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicLoadOrdering) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicStoreOrdering) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: FWDebug.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, successOrdering: FWDebug.AtomicUpdateOrdering, failureOrdering: FWDebug.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
postfix operator ~
public struct ProtocolDescriptor : FWDebug.ContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var protocolFlags: FWDebug.ProtocolDescriptor.Flags {
    get
  }
  public var name: Swift.String {
    get
  }
  public var numRequirementsInSignature: Swift.Int {
    get
  }
  public var numRequirements: Swift.Int {
    get
  }
  public var associatedTypeNames: Swift.String {
    get
  }
  public var requirementSignature: [FWDebug.GenericRequirementDescriptor] {
    get
  }
  public var requirements: [FWDebug.ProtocolRequirement] {
    get
  }
}
extension FWDebug.ProtocolDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.ProtocolDescriptor, b: FWDebug.ProtocolDescriptor) -> Swift.Bool
}
public struct ProtocolRequirement {
  public var flags: FWDebug.ProtocolRequirement.Flags {
    get
  }
}
extension FWDebug.ConformanceDescriptor {
  public struct Flags {
    public let bits: Swift.UInt32
    public var hasGenericWitnessTable: Swift.Bool {
      get
    }
    public var hasResilientWitnesses: Swift.Bool {
      get
    }
    public var isRetroactive: Swift.Bool {
      get
    }
    public var isSynthesizedNonUnique: Swift.Bool {
      get
    }
    public var numConditionalRequirements: Swift.Int {
      get
    }
    public var typeReferenceKind: FWDebug.TypeReferenceKind {
      get
    }
  }
}
public struct StructDescriptor : FWDebug.TypeContextDescriptor {
  public let ptr: Swift.UnsafeRawPointer
  public var numFields: Swift.Int {
    get
  }
  public var fieldOffsetVectorOffset: Swift.Int {
    get
  }
  public var foreignMetadataInitialization: FWDebug.ForeignMetadataInitialization? {
    get
  }
  public var singletonMetadataInitialization: FWDebug.SingletonMetadataInitialization? {
    get
  }
}
extension FWDebug.StructDescriptor : Swift.Equatable {
  public static func == (a: FWDebug.StructDescriptor, b: FWDebug.StructDescriptor) -> Swift.Bool
}
public struct StructMetadata : FWDebug.TypeMetadata {
  public let ptr: Swift.UnsafeRawPointer
  public var descriptor: FWDebug.StructDescriptor {
    get
  }
  public var fieldOffsets: [Swift.Int] {
    get
  }
}
extension FWDebug.StructMetadata : Swift.Equatable {
  public static func == (a: FWDebug.StructMetadata, b: FWDebug.StructMetadata) -> Swift.Bool
}
public struct TupleMetadata : FWDebug.Metadata {
  public let ptr: Swift.UnsafeRawPointer
  public var numElements: Swift.Int {
    get
  }
  public var labels: [Swift.String] {
    get
  }
  public var elements: [FWDebug.TupleMetadata.Element] {
    get
  }
}
extension FWDebug.TupleMetadata {
  public struct Element {
    public var type: any Any.Type {
      get
    }
    public var metadata: any FWDebug.Metadata {
      get
    }
    public var offset: Swift.Int {
      get
    }
  }
}
extension FWDebug.TupleMetadata : Swift.Equatable {
  public static func == (a: FWDebug.TupleMetadata, b: FWDebug.TupleMetadata) -> Swift.Bool
}
public protocol TypeContextDescriptor : FWDebug.ContextDescriptor {
  var typeFlags: FWDebug.TypeContextDescriptorFlags { get }
  var name: Swift.String { get }
  var accessor: FWDebug.MetadataAccessFunction { get }
  var fields: FWDebug.FieldDescriptor { get }
  var foreignMetadataInitialization: FWDebug.ForeignMetadataInitialization? { get }
  var singletonMetadataInitialization: FWDebug.SingletonMetadataInitialization? { get }
}
extension FWDebug.TypeContextDescriptor {
  public var typeFlags: FWDebug.TypeContextDescriptorFlags {
    get
  }
  public var name: Swift.String {
    get
  }
  public var accessor: FWDebug.MetadataAccessFunction {
    get
  }
  public var isReflectable: Swift.Bool {
    get
  }
  public var fields: FWDebug.FieldDescriptor {
    get
  }
  public var typeGenericContext: FWDebug.TypeGenericContext {
    get
  }
}
public struct ForeignMetadataInitialization {
}
public struct SingletonMetadataInitialization {
}
public protocol TypeMetadata : FWDebug.Metadata {
}
extension FWDebug.TypeMetadata {
  public var conformances: [FWDebug.ConformanceDescriptor] {
    get
  }
  public var contextDescriptor: any FWDebug.TypeContextDescriptor {
    get
  }
  public var fieldOffsets: [Swift.Int] {
    get
  }
  public var genericTypes: [any Any.Type] {
    get
  }
  public var genericMetadata: [any FWDebug.Metadata] {
    get
  }
  public func type(of mangledName: Swift.UnsafeRawPointer) -> (any Any.Type)?
}
public struct ValueWitnessTable {
  public func initializeBufferWithCopyOfBuffer(_ dest: Swift.UnsafeMutableRawPointer, _ source: Swift.UnsafeMutableRawPointer)
  public func destroy(_ value: Swift.UnsafeMutableRawPointer)
  public func initializeWithCopy(_ dest: Swift.UnsafeMutableRawPointer, _ source: Swift.UnsafeMutableRawPointer)
  public func assignWithCopy(_ dest: Swift.UnsafeMutableRawPointer, _ source: Swift.UnsafeMutableRawPointer)
  public func initializeWithTake(_ dest: Swift.UnsafeMutableRawPointer, _ source: Swift.UnsafeMutableRawPointer)
  public func assignWithTake(_ dest: Swift.UnsafeMutableRawPointer, _ source: Swift.UnsafeMutableRawPointer)
  public func getEnumTagSinglePayload(_ instance: Swift.UnsafeRawPointer, _ numEmptyCases: Swift.UInt32) -> Swift.UInt32
  public func storeEnumTagSinglePayload(_ instance: Swift.UnsafeMutableRawPointer, _ tag: Swift.UInt32, _ numEmptyCases: Swift.UInt32)
  public var size: Swift.Int {
    get
  }
  public var stride: Swift.Int {
    get
  }
  public var flags: FWDebug.ValueWitnessTable.Flags {
    get
  }
  public var extraInhabitantCount: Swift.Int {
    get
  }
}
public struct WitnessTable {
  public var conformanceDescriptor: FWDebug.ConformanceDescriptor {
    get
  }
}
extension Swift.Bool.AtomicRepresentation : Swift.Sendable {}
extension FWDebug.UnsafeAtomicLazyReference.Storage : Swift.Sendable {}
extension FWDebug.AtomicLoadOrdering : Swift.Sendable {}
extension FWDebug.AtomicStoreOrdering : Swift.Sendable {}
extension FWDebug.AtomicUpdateOrdering : Swift.Sendable {}
extension FWDebug.ContextDescriptorKind : Swift.Equatable {}
extension FWDebug.ContextDescriptorKind : Swift.Hashable {}
extension FWDebug.ContextDescriptorKind : Swift.RawRepresentable {}
extension FWDebug.FieldDescriptor.Kind : Swift.Equatable {}
extension FWDebug.FieldDescriptor.Kind : Swift.Hashable {}
extension FWDebug.FieldDescriptor.Kind : Swift.RawRepresentable {}
extension FWDebug.GenericParameterKind : Swift.Equatable {}
extension FWDebug.GenericParameterKind : Swift.Hashable {}
extension FWDebug.GenericParameterKind : Swift.RawRepresentable {}
extension FWDebug.GenericRequirementKind : Swift.Equatable {}
extension FWDebug.GenericRequirementKind : Swift.Hashable {}
extension FWDebug.GenericRequirementKind : Swift.RawRepresentable {}
extension FWDebug.GenericRequirementLayoutKind : Swift.Equatable {}
extension FWDebug.GenericRequirementLayoutKind : Swift.Hashable {}
extension FWDebug.GenericRequirementLayoutKind : Swift.RawRepresentable {}
extension FWDebug.MethodDescriptor.Kind : Swift.Equatable {}
extension FWDebug.MethodDescriptor.Kind : Swift.Hashable {}
extension FWDebug.MethodDescriptor.Kind : Swift.RawRepresentable {}
extension FWDebug.ProtocolRequirement.Kind : Swift.Equatable {}
extension FWDebug.ProtocolRequirement.Kind : Swift.Hashable {}
extension FWDebug.ProtocolRequirement.Kind : Swift.RawRepresentable {}
extension FWDebug.ReferenceStorageKind : Swift.Equatable {}
extension FWDebug.ReferenceStorageKind : Swift.Hashable {}
extension FWDebug.ReferenceStorageKind : Swift.RawRepresentable {}
extension FWDebug.MetadataInitializationKind : Swift.Equatable {}
extension FWDebug.MetadataInitializationKind : Swift.Hashable {}
extension FWDebug.MetadataInitializationKind : Swift.RawRepresentable {}
extension FWDebug.TypeReferenceKind : Swift.Equatable {}
extension FWDebug.TypeReferenceKind : Swift.Hashable {}
extension FWDebug.TypeReferenceKind : Swift.RawRepresentable {}
extension FWDebug.MetadataKind : Swift.Equatable {}
extension FWDebug.MetadataKind : Swift.Hashable {}
extension FWDebug.MetadataKind : Swift.RawRepresentable {}
extension Swift.Int.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int64.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int32.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int16.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int8.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt64.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt32.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt16.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt8.AtomicRepresentation : Swift.Sendable {}
extension FWDebug.DoubleWord.AtomicRepresentation : Swift.Sendable {}
extension FWDebug.MetadataState : Swift.Equatable {}
extension FWDebug.MetadataState : Swift.Hashable {}
extension FWDebug.MetadataState : Swift.RawRepresentable {}
extension FWDebug.SpecialProtocol : Swift.Equatable {}
extension FWDebug.SpecialProtocol : Swift.Hashable {}
extension FWDebug.SpecialProtocol : Swift.RawRepresentable {}
extension FWDebug.FunctionConvention : Swift.Equatable {}
extension FWDebug.FunctionConvention : Swift.Hashable {}
extension FWDebug.FunctionConvention : Swift.RawRepresentable {}
extension FWDebug.ValueOwnership : Swift.Equatable {}
extension FWDebug.ValueOwnership : Swift.Hashable {}
extension FWDebug.ValueOwnership : Swift.RawRepresentable {}
extension Swift.UnsafeRawPointer.AtomicRepresentation : Swift.Sendable {}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation : Swift.Sendable {}
extension Swift.UnsafePointer.AtomicRepresentation : Swift.Sendable {}
extension Swift.UnsafeMutablePointer.AtomicRepresentation : Swift.Sendable {}
extension Swift.Unmanaged.AtomicRepresentation : Swift.Sendable {}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation : Swift.Sendable {}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation : Swift.Sendable {}
extension Swift.UnsafePointer.AtomicOptionalRepresentation : Swift.Sendable {}
extension Swift.UnsafeMutablePointer.AtomicOptionalRepresentation : Swift.Sendable {}
extension Swift.Unmanaged.AtomicOptionalRepresentation : Swift.Sendable {}
